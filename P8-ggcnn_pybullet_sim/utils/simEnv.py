import pybullet as p
import pybullet_data
import time
import math
import os
import glob
import random
import cv2
import shutil
import numpy as np
import scipy.io as scio
import sys
import scipy.stats as ss
import skimage.transform as skt


# Image dimensions
IMAGEWIDTH = 640
IMAGEHEIGHT = 480

nearPlane = 0.01  # Near clipping plane
farPlane = 10     # Far clipping plane

fov = 60    # Vertical field of view (in degrees). Image height = tan(30) * 0.7 * 2 = 0.8082903m
aspect = IMAGEWIDTH / IMAGEHEIGHT  # Aspect ratio of the camera


def imresize(image, size, interp="nearest"):
    """
    Resize image using skimage transform with specified interpolation method.
    
    Args:
        image: Input image array
        size: Target size (tuple/list) or scale factor (float/int)
        interp: Interpolation method ("nearest", "bilinear", etc.)
    
    Returns:
        Resized image array
    """
    skt_interp_map = {
        "nearest": 0,
        "bilinear": 1,
        "biquadratic": 2,
        "bicubic": 3,
        "biquartic": 4,
        "biquintic": 5
    }
    if interp in ("lanczos", "cubic"):
        raise ValueError("'lanczos' and 'cubic'"
                         " interpolation are no longer supported.")
    assert interp in skt_interp_map, ("Interpolation '{}' not"
                                      " supported.".format(interp))

    if isinstance(size, (tuple, list)):
        output_shape = size
    elif isinstance(size, (float)):
        np_shape = np.asarray(image.shape).astype(np.float32)
        np_shape[0:2] *= size
        output_shape = tuple(np_shape.astype(int))
    elif isinstance(size, (int)):
        np_shape = np.asarray(image.shape).astype(np.float32)
        np_shape[0:2] *= size / 100.0
        output_shape = tuple(np_shape.astype(int))
    else:
        raise ValueError("Invalid type for size '{}'.".format(type(size)))

    return skt.resize(image,
                      output_shape,
                      order=skt_interp_map[interp],
                      anti_aliasing=False,
                      mode="constant")

def inpaint(img, missing_value=0):
    """
    Inpaint missing values in depth image using OpenCV's inpainting algorithm.
    
    Args:
        img: Input depth image
        missing_value: Value to be considered as missing (default: 0)
    
    Returns:
        Inpainted image with missing values filled
    """
    img = cv2.copyMakeBorder(img, 1, 1, 1, 1, cv2.BORDER_DEFAULT)
    mask = (img == missing_value).astype(np.uint8)

    # Scale to keep as float, but has to be in bounds -1:1 to keep opencv happy
    scale = np.abs(img).max()
    img = img.astype(np.float32) / scale  # Has to be float32, 64 not supported
    img = cv2.inpaint(img, mask, 1, cv2.INPAINT_NS)

    # Back to original size and value range
    img = img[1:-1, 1:-1]
    img = img * scale

    return img


class SimEnv(object):
    """
    Virtual Environment Class
    
    Handles the simulation environment including object loading, camera setup,
    and environment manipulation.
    """
    def __init__(self, bullet_client, path, gripperId=None):
        """
        Initialize simulation environment
        
        Args:
            bullet_client: PyBullet client instance
            path: Path to model directory
            gripperId: ID of the gripper if present (default: None)
        """
        self.p = bullet_client
        self.p.setPhysicsEngineParameter(maxNumCmdPer1ms=1000, solverResidualThreshold=0, enableFileCaching=0)
        self.p.resetDebugVisualizerCamera(cameraDistance=1.3, cameraYaw=38, cameraPitch=-22, cameraTargetPosition=[0, 0, 0])
        self.p.setAdditionalSearchPath(pybullet_data.getDataPath())  # Add search path
        self.planeId = self.p.loadURDF("plane.urdf", [0, 0, 0])  # Load ground plane    
        self.trayId = self.p.loadURDF('../models/tray/tray_small.urdf', [0, 0, -0.007])
        self.p.setGravity(0, 0, -10)  # Set gravity
        self.flags = self.p.URDF_ENABLE_CACHED_GRAPHICS_SHAPES
        self.gripperId = gripperId

        # Initialize camera
        self.movecamera(0, 0)
        self.projectionMatrix = self.p.computeProjectionMatrixFOV(fov, aspect, nearPlane, farPlane)

        # Read object list from path
        list_file = os.path.join(path, 'list.txt')
        if not os.path.exists(list_file):
            raise shutil.Error
        self.urdfs_list = []
        with open(list_file, 'r') as f:
            while 1:
                line = f.readline()
                if not line:
                    break
                self.urdfs_list.append(os.path.join(path, line[:-1]+'.urdf'))

        self.num_urdf = 0  # Number of loaded URDFs
        self.urdfs_id = []  # Store model IDs generated by PyBullet
        self.objs_id = []   # Store model indices in file list (only used when path is str)
        
        # Predefined rotation angles for objects
        self.EulerRPList = [[0, 0], [math.pi/2, 0], [-1*math.pi/2, 0], 
                           [math.pi, 0], [0, math.pi/2], [0, -1*math.pi/2]]
        
    def _urdf_nums(self):
        """
        Get the total number of available URDF models
        
        Returns:
            int: Number of URDF models in the list
        """
        return len(self.urdfs_list)
    

    def movecamera(self, x, y, z=0.7):
        """
        Move camera to specified position in world coordinates
        
        Args:
            x: X coordinate in world frame
            y: Y coordinate in world frame
            z: Z coordinate in world frame (default: 0.7m)
        """
        self.viewMatrix = self.p.computeViewMatrix([x, y, z], [x, y, 0], [0, 1, 0])   # Camera height set to 0.7m


    def loadObjInURDF(self, urdf_file, idx, render_n=0):
        """
        Load a single object in URDF format
        
        Args:
            urdf_file: Path to URDF file
            idx: Object ID (-1 if using direct file path)
            render_n: Current rendering count for object orientation
        """
        # Get object file
        if idx >= 0:
            self.urdfs_filename = [self.urdfs_list[idx]]
            self.objs_id = [idx]
        else:
            self.urdfs_filename = [urdf_file]
            self.objs_id = [-1]
        self.num_urdf = 1

        self.urdfs_id = []
        self.urdfs_xyz = []
        self.urdfs_scale = []

        # Random orientation
        baseEuler = [random.uniform(0, 2*math.pi), 
                    random.uniform(0, 2*math.pi), 
                    random.uniform(0, 2*math.pi)]
        baseOrientation = self.p.getQuaternionFromEuler(baseEuler)

        # Random position
        pos = 0.1  # Position range
        basePosition = [random.uniform(-1 * pos, pos), 
                    random.uniform(-1 * pos, pos), 
                    random.uniform(0.1, 0.4)]

        # Load object
        urdf_id = self.p.loadURDF(self.urdfs_filename[0], basePosition, baseOrientation)    

        # Get xyz and scale information
        inf = self.p.getVisualShapeData(urdf_id)[0]

        self.urdfs_id.append(urdf_id)
        self.urdfs_xyz.append(inf[5]) 
        self.urdfs_scale.append(inf[3][0]) 


    def loadObjsInURDF(self, idx, num):
        """
        Load multiple objects in URDF format
        
        Args:
            num: Number of objects to load
            idx: Starting ID
                negative: randomly load num objects
                non-negative: load num objects starting from idx
        """
        assert idx >= 0 and idx < len(self.urdfs_list)
        self.num_urdf = num

        # Get object files
        if (idx + self.num_urdf - 1) > (len(self.urdfs_list) - 1):
            self.urdfs_filename = self.urdfs_list[idx:]
            self.urdfs_filename += self.urdfs_list[:2*self.num_urdf-len(self.urdfs_list)+idx]
            self.objs_id = list(range(idx, len(self.urdfs_list)))
            self.objs_id += list(range(self.num_urdf-len(self.urdfs_list)+idx))
        else:
            self.urdfs_filename = self.urdfs_list[idx:idx+self.num_urdf]
            self.objs_id = list(range(idx, idx+self.num_urdf))

        print('Object IDs = \n', self.objs_id)

        self.urdfs_id = []
        self.urdfs_xyz = []
        self.urdfs_scale = []
        
        for i in range(self.num_urdf):
            # Random position
            pos = 0.1
            basePosition = [random.uniform(-1 * pos, pos), 
                        random.uniform(-1 * pos, pos), 
                        random.uniform(0.2, 0.3)]

            # Random orientation
            baseEuler = [random.uniform(0, 2*math.pi), 
                        random.uniform(0, 2*math.pi), 
                        random.uniform(0, 2*math.pi)]
            baseOrientation = self.p.getQuaternionFromEuler(baseEuler)
            
            # Load object
            urdf_id = self.p.loadURDF(self.urdfs_filename[i], basePosition, baseOrientation)    
            
            # Enable collision between gripper and object if gripper exists
            if self.gripperId is not None:
                self.p.setCollisionFilterPair(urdf_id, self.gripperId, -1, 0, 1)
                self.p.setCollisionFilterPair(urdf_id, self.gripperId, -1, 1, 1)
                self.p.setCollisionFilterPair(urdf_id, self.gripperId, -1, 2, 1)

            # Get xyz and scale information
            inf = self.p.getVisualShapeData(urdf_id)[0]

            self.urdfs_id.append(urdf_id)
            self.urdfs_xyz.append(inf[5]) 
            self.urdfs_scale.append(inf[3][0]) 
            
            # Let physics simulation stabilize
            t = 0
            while True:
                p.stepSimulation()
                t += 1
                if t == 120:
                    break


    def evalGrasp(self, z_thresh):
        """
        Evaluate if grasp is successful
        
        Args:
            z_thresh: Z-coordinate threshold. Object above this is considered grasped
            
        Returns:
            bool: True if grasp successful, False otherwise
        """
        for i in range(self.num_urdf):
            offset, _ =  self.p.getBasePositionAndOrientation(self.urdfs_id[i])
            if offset[2] >= z_thresh:
                print('!!!!!!!!!!!!!!!!!!!!! Success !!!!!!!!!!!!!!!!!!!!!')
                return True
        print('!!!!!!!!!!!!!!!!!!!!! Failed !!!!!!!!!!!!!!!!!!!!!')
        return False


    def evalGraspAndRemove(self, z_thresh):
        """
        Evaluate grasp success and remove grasped object
        
        Args:
            z_thresh: Z-coordinate threshold. Object above this is considered grasped
            
        Returns:
            bool: True if grasp successful, False otherwise
        """
        for i in range(self.num_urdf):
            offset, _ =  self.p.getBasePositionAndOrientation(self.urdfs_id[i])
            if offset[2] >= z_thresh:
                self.removeObjInURDF(i)
                print('!!!!!!!!!!!!!!!!!!!!! Success !!!!!!!!!!!!!!!!!!!!!')
                return True
        print('!!!!!!!!!!!!!!!!!!!!! Failed !!!!!!!!!!!!!!!!!!!!!')
        return False


    def resetObjsPoseRandom(self):
        """
        Randomly reset positions of all objects in the scene
        """
        for i in range(self.num_urdf):
            pos = 0.1
            basePosition = [random.uniform(-1 * pos, pos), 
                        random.uniform(-1 * pos, pos), 
                        random.uniform(0.3, 0.6)]
            baseEuler = [random.uniform(0, 2*math.pi), 
                        random.uniform(0, 2*math.pi), 
                        random.uniform(0, 2*math.pi)]
            baseOrientation = self.p.getQuaternionFromEuler(baseEuler)
            self.p.resetBasePositionAndOrientation(self.urdfs_id[i], 
                                                basePosition, 
                                                baseOrientation)

            # Let physics simulation stabilize
            t = 0
            while True:
                p.stepSimulation()
                t += 1
                if t == 120:
                    break


    def removeObjsInURDF(self):
        """
        Remove all objects from the scene and reset object counters
        """
        for i in range(self.num_urdf):
            self.p.removeBody(self.urdfs_id[i])
        self.num_urdf = 0
        self.urdfs_id = []
        self.urdfs_xyz = []
        self.urdfs_scale = []
        self.urdfs_filename = []
        self.objs_id = []


    def removeObjInURDF(self, i):
        """
        Remove specified object from the scene
        
        Args:
            i: Index of object to remove
        """
        self.num_urdf -= 1
        self.p.removeBody(self.urdfs_id[i])
        self.urdfs_id.pop(i)
        self.urdfs_xyz.pop(i)
        self.urdfs_scale.pop(i)
        self.urdfs_filename.pop(i)
        self.objs_id.pop(i)


    def renderCameraDepthImage(self):
        """
        Render depth image from camera viewpoint
        
        Returns:
            numpy.ndarray: Depth image in meters
        """
        # Render image
        img_camera = self.p.getCameraImage(
            IMAGEWIDTH, 
            IMAGEHEIGHT, 
            self.viewMatrix, 
            self.projectionMatrix, 
            renderer=p.ER_BULLET_HARDWARE_OPENGL
        )
        w = img_camera[0]      # Width of the image, in pixels
        h = img_camera[1]      # Height of the image, in pixels
        dep = img_camera[3]    # Depth data

        # Convert depth buffer to actual depth
        depth = np.reshape(dep, (h, w))
        A = np.ones((IMAGEHEIGHT, IMAGEWIDTH), dtype=np.float64) * farPlane * nearPlane
        B = np.ones((IMAGEHEIGHT, IMAGEWIDTH), dtype=np.float64) * farPlane
        C = np.ones((IMAGEHEIGHT, IMAGEWIDTH), dtype=np.float64) * (farPlane - nearPlane)
        im_depthCamera = np.divide(A, (np.subtract(B, np.multiply(C, depth))))  # Units in meters
        return im_depthCamera


    def renderCameraMask(self):
        """
        Render segmentation mask from camera viewpoint
        
        Returns:
            numpy.ndarray: Segmentation mask (255 for objects, 0 for background)
        """
        # Render image
        img_camera = self.p.getCameraImage(
            IMAGEWIDTH, 
            IMAGEHEIGHT, 
            self.viewMatrix, 
            self.projectionMatrix, 
            renderer=p.ER_BULLET_HARDWARE_OPENGL
        )
        w = img_camera[0]      # Width of the image, in pixels
        h = img_camera[1]      # Height of the image, in pixels
        mask = img_camera[4]   # Segmentation mask data

        # Process segmentation mask
        im_mask = np.reshape(mask, (h, w)).astype(np.uint8)
        im_mask[im_mask > 2] = 255  # Set all objects to 255
        return im_mask


    def gaussian_noise(self, im_depth):
        """
        Add Gaussian noise to depth image (based on Dex-Net implementation)
        
        Args:
            im_depth: Float depth image in meters
            
        Returns:
            numpy.ndarray: Depth image with added noise
        """
        gamma_shape = 1000.00
        gamma_scale = 1 / gamma_shape
        gaussian_process_sigma = 0.002
        gaussian_process_scaling_factor = 8.0

        im_height, im_width = im_depth.shape
        
        # Add Gaussian Process noise
        gp_rescale_factor = gaussian_process_scaling_factor
        gp_sample_height = int(im_height / gp_rescale_factor)
        gp_sample_width = int(im_width / gp_rescale_factor)
        gp_num_pix = gp_sample_height * gp_sample_width
        gp_sigma = gaussian_process_sigma
        
        # Generate and apply noise
        gp_noise = ss.norm.rvs(scale=gp_sigma, 
                            size=gp_num_pix).reshape(gp_sample_height, gp_sample_width)
        gp_noise = imresize(gp_noise, gp_rescale_factor, interp="bicubic")
        im_depth += gp_noise

        return im_depth


    def add_noise(self, img):
        """
        Add noise to depth image
        
        Args:
            img: Input depth image
            
        Returns:
            numpy.ndarray: Depth image with added noise
        """
        img = self.gaussian_noise(img)    # Add Gaussian noise
        return img